// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	sync "sync"
	time "time"

	db "github.com/concourse/concourse/atc/db"
)

type FakeContainerRepository struct {
	DestroyFailedContainersStub        func() (int, error)
	destroyFailedContainersMutex       sync.RWMutex
	destroyFailedContainersArgsForCall []struct {
	}
	destroyFailedContainersReturns struct {
		result1 int
		result2 error
	}
	destroyFailedContainersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	FindDestroyingContainersStub        func(string) ([]string, error)
	findDestroyingContainersMutex       sync.RWMutex
	findDestroyingContainersArgsForCall []struct {
		arg1 string
	}
	findDestroyingContainersReturns struct {
		result1 []string
		result2 error
	}
	findDestroyingContainersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	FindOrphanedContainersStub        func() ([]db.CreatingContainer, []db.CreatedContainer, []db.DestroyingContainer, error)
	findOrphanedContainersMutex       sync.RWMutex
	findOrphanedContainersArgsForCall []struct {
	}
	findOrphanedContainersReturns struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}
	findOrphanedContainersReturnsOnCall map[int]struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}
	RemoveDestroyingContainersStub        func(string, []string) (int, error)
	removeDestroyingContainersMutex       sync.RWMutex
	removeDestroyingContainersArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	removeDestroyingContainersReturns struct {
		result1 int
		result2 error
	}
	removeDestroyingContainersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	RemoveMissingContainersStub        func(time.Duration) (int, error)
	removeMissingContainersMutex       sync.RWMutex
	removeMissingContainersArgsForCall []struct {
		arg1 time.Duration
	}
	removeMissingContainersReturns struct {
		result1 int
		result2 error
	}
	removeMissingContainersReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	UpdateContainersLastSeenStub        func([]string) error
	updateContainersLastSeenMutex       sync.RWMutex
	updateContainersLastSeenArgsForCall []struct {
		arg1 []string
	}
	updateContainersLastSeenReturns struct {
		result1 error
	}
	updateContainersLastSeenReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContainerRepository) DestroyFailedContainers() (int, error) {
	fake.destroyFailedContainersMutex.Lock()
	ret, specificReturn := fake.destroyFailedContainersReturnsOnCall[len(fake.destroyFailedContainersArgsForCall)]
	fake.destroyFailedContainersArgsForCall = append(fake.destroyFailedContainersArgsForCall, struct {
	}{})
	fake.recordInvocation("DestroyFailedContainers", []interface{}{})
	fake.destroyFailedContainersMutex.Unlock()
	if fake.DestroyFailedContainersStub != nil {
		return fake.DestroyFailedContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.destroyFailedContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) DestroyFailedContainersCallCount() int {
	fake.destroyFailedContainersMutex.RLock()
	defer fake.destroyFailedContainersMutex.RUnlock()
	return len(fake.destroyFailedContainersArgsForCall)
}

func (fake *FakeContainerRepository) DestroyFailedContainersReturns(result1 int, result2 error) {
	fake.DestroyFailedContainersStub = nil
	fake.destroyFailedContainersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) DestroyFailedContainersReturnsOnCall(i int, result1 int, result2 error) {
	fake.DestroyFailedContainersStub = nil
	if fake.destroyFailedContainersReturnsOnCall == nil {
		fake.destroyFailedContainersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.destroyFailedContainersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindDestroyingContainers(arg1 string) ([]string, error) {
	fake.findDestroyingContainersMutex.Lock()
	ret, specificReturn := fake.findDestroyingContainersReturnsOnCall[len(fake.findDestroyingContainersArgsForCall)]
	fake.findDestroyingContainersArgsForCall = append(fake.findDestroyingContainersArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindDestroyingContainers", []interface{}{arg1})
	fake.findDestroyingContainersMutex.Unlock()
	if fake.FindDestroyingContainersStub != nil {
		return fake.FindDestroyingContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findDestroyingContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) FindDestroyingContainersCallCount() int {
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	return len(fake.findDestroyingContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindDestroyingContainersArgsForCall(i int) string {
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	argsForCall := fake.findDestroyingContainersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerRepository) FindDestroyingContainersReturns(result1 []string, result2 error) {
	fake.FindDestroyingContainersStub = nil
	fake.findDestroyingContainersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindDestroyingContainersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.FindDestroyingContainersStub = nil
	if fake.findDestroyingContainersReturnsOnCall == nil {
		fake.findDestroyingContainersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findDestroyingContainersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) FindOrphanedContainers() ([]db.CreatingContainer, []db.CreatedContainer, []db.DestroyingContainer, error) {
	fake.findOrphanedContainersMutex.Lock()
	ret, specificReturn := fake.findOrphanedContainersReturnsOnCall[len(fake.findOrphanedContainersArgsForCall)]
	fake.findOrphanedContainersArgsForCall = append(fake.findOrphanedContainersArgsForCall, struct {
	}{})
	fake.recordInvocation("FindOrphanedContainers", []interface{}{})
	fake.findOrphanedContainersMutex.Unlock()
	if fake.FindOrphanedContainersStub != nil {
		return fake.FindOrphanedContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	fakeReturns := fake.findOrphanedContainersReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeContainerRepository) FindOrphanedContainersCallCount() int {
	fake.findOrphanedContainersMutex.RLock()
	defer fake.findOrphanedContainersMutex.RUnlock()
	return len(fake.findOrphanedContainersArgsForCall)
}

func (fake *FakeContainerRepository) FindOrphanedContainersReturns(result1 []db.CreatingContainer, result2 []db.CreatedContainer, result3 []db.DestroyingContainer, result4 error) {
	fake.FindOrphanedContainersStub = nil
	fake.findOrphanedContainersReturns = struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeContainerRepository) FindOrphanedContainersReturnsOnCall(i int, result1 []db.CreatingContainer, result2 []db.CreatedContainer, result3 []db.DestroyingContainer, result4 error) {
	fake.FindOrphanedContainersStub = nil
	if fake.findOrphanedContainersReturnsOnCall == nil {
		fake.findOrphanedContainersReturnsOnCall = make(map[int]struct {
			result1 []db.CreatingContainer
			result2 []db.CreatedContainer
			result3 []db.DestroyingContainer
			result4 error
		})
	}
	fake.findOrphanedContainersReturnsOnCall[i] = struct {
		result1 []db.CreatingContainer
		result2 []db.CreatedContainer
		result3 []db.DestroyingContainer
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeContainerRepository) RemoveDestroyingContainers(arg1 string, arg2 []string) (int, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.removeDestroyingContainersMutex.Lock()
	ret, specificReturn := fake.removeDestroyingContainersReturnsOnCall[len(fake.removeDestroyingContainersArgsForCall)]
	fake.removeDestroyingContainersArgsForCall = append(fake.removeDestroyingContainersArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	fake.recordInvocation("RemoveDestroyingContainers", []interface{}{arg1, arg2Copy})
	fake.removeDestroyingContainersMutex.Unlock()
	if fake.RemoveDestroyingContainersStub != nil {
		return fake.RemoveDestroyingContainersStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removeDestroyingContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersCallCount() int {
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	return len(fake.removeDestroyingContainersArgsForCall)
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersArgsForCall(i int) (string, []string) {
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	argsForCall := fake.removeDestroyingContainersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersReturns(result1 int, result2 error) {
	fake.RemoveDestroyingContainersStub = nil
	fake.removeDestroyingContainersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) RemoveDestroyingContainersReturnsOnCall(i int, result1 int, result2 error) {
	fake.RemoveDestroyingContainersStub = nil
	if fake.removeDestroyingContainersReturnsOnCall == nil {
		fake.removeDestroyingContainersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.removeDestroyingContainersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) RemoveMissingContainers(arg1 time.Duration) (int, error) {
	fake.removeMissingContainersMutex.Lock()
	ret, specificReturn := fake.removeMissingContainersReturnsOnCall[len(fake.removeMissingContainersArgsForCall)]
	fake.removeMissingContainersArgsForCall = append(fake.removeMissingContainersArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("RemoveMissingContainers", []interface{}{arg1})
	fake.removeMissingContainersMutex.Unlock()
	if fake.RemoveMissingContainersStub != nil {
		return fake.RemoveMissingContainersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removeMissingContainersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContainerRepository) RemoveMissingContainersCallCount() int {
	fake.removeMissingContainersMutex.RLock()
	defer fake.removeMissingContainersMutex.RUnlock()
	return len(fake.removeMissingContainersArgsForCall)
}

func (fake *FakeContainerRepository) RemoveMissingContainersArgsForCall(i int) time.Duration {
	fake.removeMissingContainersMutex.RLock()
	defer fake.removeMissingContainersMutex.RUnlock()
	argsForCall := fake.removeMissingContainersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerRepository) RemoveMissingContainersReturns(result1 int, result2 error) {
	fake.RemoveMissingContainersStub = nil
	fake.removeMissingContainersReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) RemoveMissingContainersReturnsOnCall(i int, result1 int, result2 error) {
	fake.RemoveMissingContainersStub = nil
	if fake.removeMissingContainersReturnsOnCall == nil {
		fake.removeMissingContainersReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.removeMissingContainersReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeContainerRepository) UpdateContainersLastSeen(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateContainersLastSeenMutex.Lock()
	ret, specificReturn := fake.updateContainersLastSeenReturnsOnCall[len(fake.updateContainersLastSeenArgsForCall)]
	fake.updateContainersLastSeenArgsForCall = append(fake.updateContainersLastSeenArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("UpdateContainersLastSeen", []interface{}{arg1Copy})
	fake.updateContainersLastSeenMutex.Unlock()
	if fake.UpdateContainersLastSeenStub != nil {
		return fake.UpdateContainersLastSeenStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateContainersLastSeenReturns
	return fakeReturns.result1
}

func (fake *FakeContainerRepository) UpdateContainersLastSeenCallCount() int {
	fake.updateContainersLastSeenMutex.RLock()
	defer fake.updateContainersLastSeenMutex.RUnlock()
	return len(fake.updateContainersLastSeenArgsForCall)
}

func (fake *FakeContainerRepository) UpdateContainersLastSeenArgsForCall(i int) []string {
	fake.updateContainersLastSeenMutex.RLock()
	defer fake.updateContainersLastSeenMutex.RUnlock()
	argsForCall := fake.updateContainersLastSeenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContainerRepository) UpdateContainersLastSeenReturns(result1 error) {
	fake.UpdateContainersLastSeenStub = nil
	fake.updateContainersLastSeenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerRepository) UpdateContainersLastSeenReturnsOnCall(i int, result1 error) {
	fake.UpdateContainersLastSeenStub = nil
	if fake.updateContainersLastSeenReturnsOnCall == nil {
		fake.updateContainersLastSeenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateContainersLastSeenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContainerRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.destroyFailedContainersMutex.RLock()
	defer fake.destroyFailedContainersMutex.RUnlock()
	fake.findDestroyingContainersMutex.RLock()
	defer fake.findDestroyingContainersMutex.RUnlock()
	fake.findOrphanedContainersMutex.RLock()
	defer fake.findOrphanedContainersMutex.RUnlock()
	fake.removeDestroyingContainersMutex.RLock()
	defer fake.removeDestroyingContainersMutex.RUnlock()
	fake.removeMissingContainersMutex.RLock()
	defer fake.removeMissingContainersMutex.RUnlock()
	fake.updateContainersLastSeenMutex.RLock()
	defer fake.updateContainersLastSeenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContainerRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ContainerRepository = new(FakeContainerRepository)
